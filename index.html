<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Kiznaiver,undefined"><meta name="copyright" content="Kiznaiver"><title>记录成长 | Code Kiznaiver</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="http://i2.tiimg.com/695979/85f0ddcc268be3e6.jpg"></div><div class="author-info__name text-center">Kiznaiver</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">6</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">4</span></a></div></div></div><nav class="http://i1.fuimg.com/695979/aefa8138a26b53d8.jpg" id="nav" style="background-image: url(http://i1.fuimg.com/695979/aefa8138a26b53d8.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Code Kiznaiver</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="site-info"><div id="site-title">Code Kiznaiver</div><div id="site-sub-title">记录成长</div><div id="site-social-icons"> <a class="social-icon" href="https://github.com/Kiznaiver1998" target="_blank"><i class="fa fa-github fab"></i></a><a class="social-icon" href="https://www.yuque.com/fe9/basic/fov5og" target="_blank"><i class="fa fa-bookmark fab"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/03/blog-remove-3/">blog-remove</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-03</time><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/03/Hello-World/">Hello World</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-03</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/折腾/">折腾</a></span><div class="content"><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>Blog新鲜出炉啦，而且感觉使用hexo写blog也很方便。</p>
<p>这第一篇blog就说说怎么hexo的使用~</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure>

<h4 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g <span class="comment">#生成并本地预览</span></span><br><span class="line">hexo d -g <span class="comment">#生成并上传</span></span><br></pre></td></tr></table></figure>

<h2 id="搭建过程中遇到的一些坑"><a href="#搭建过程中遇到的一些坑" class="headerlink" title="搭建过程中遇到的一些坑"></a>搭建过程中遇到的一些坑</h2><h4 id="Cannot-read-property-‘css’-of-undefined"><a href="#Cannot-read-property-‘css’-of-undefined" class="headerlink" title="Cannot read property ‘css’ of undefined"></a>Cannot read property ‘css’ of undefined</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    29|       each url <span class="keyword">in</span> theme.stylesheets</span><br><span class="line">    30|         link(rel=<span class="string">'stylesheet'</span>, href=url_for(url) + <span class="string">'?version='</span> + version())</span><br><span class="line">  &gt; 31|     each item <span class="keyword">in</span> theme.cdn.css</span><br><span class="line">    32|       <span class="keyword">if</span> item !== undefined</span><br><span class="line">    33|         link(rel=<span class="string">'stylesheet'</span>, href=item + <span class="string">'?version='</span> + version())</span><br><span class="line">    34|     include ./head.pug</span><br><span class="line"></span><br><span class="line">Cannot <span class="built_in">read</span> property <span class="string">'css'</span> of undefined</span><br></pre></td></tr></table></figure>

<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>需要复制到Hexo/source/_data下的_config.yml是melody主题目录下的而非Hexo目录下的。</p>
<p> 用hexo命令上传github没用</p>
<h4 id="config-yml配置问题解决"><a href="#config-yml配置问题解决" class="headerlink" title="_config.yml配置问题解决"></a>_config.yml配置问题解决</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:liuxianan/liuxianan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>应该改为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:liuxianan/liuxianan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p><strong>而且不能用https开头的网址</strong></p>
<h2 id="之后的Blog优化计划"><a href="#之后的Blog优化计划" class="headerlink" title="之后的Blog优化计划"></a>之后的Blog优化计划</h2><ul>
<li><p>1.添加live2D</p>
</li>
<li><p>2.添加评论支持</p>
</li>
<li><p>3.添加统计支持</p>
</li>
<li><p>4.将其移植到自己的域名上</p>
</li>
</ul>
<hr>
<p>以上。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/07/27/blog-remove/">JS对cookie的相关操作</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-27</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JS/">JS</a></span><div class="content"><p>之前只使用过LocalStorage进行保存用户的登陆信息，今天就来使用以下cookie，感受一下它的特性。</p>
<h2 id="先po案例："><a href="#先po案例：" class="headerlink" title="先po案例："></a>先po案例：</h2><p><a href="https://codepen.io/Kiznaiver1998/pen/mNOMVy" target="_blank" rel="noopener">https://codepen.io/Kiznaiver1998/pen/mNOMVy</a></p>
<p>这个实现的是基础场景，如果用户曾经登陆过并且记住密码，那么输入用户名就自己输入密码，    并且会自己缓存最后一次登陆的用户名和密码。当然，这个案例中对于密码还是明文存储的，并不安全，实际中，应该加上md5加密之类的。而且cookie一般是用于记录用户喜好和判断是否登陆过。</p>
<p>所以我们能知道cookie是保存字符串的，写入也就是写入字符串，查询也是先把字符串利用split拆成数组，再进行分割获得目标值。</p>
<p>它的格式是“key=value;key=value;”这样子。</p>
<h2 id="安利"><a href="#安利" class="headerlink" title="安利"></a>安利</h2><p>最后对于MDN上的cookie读入/写入器也是强烈安利了：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie</a></p>
<p>再Po一道相关的笔试题：</p>
<h3 id="cookie和session分别用来做什么，有什么关系"><a href="#cookie和session分别用来做什么，有什么关系" class="headerlink" title="cookie和session分别用来做什么，有什么关系"></a>cookie和session分别用来做什么，有什么关系</h3><p>cookie用来在客户端存储用户信息，session用来在服务端存储用户数据，他们都可以用来跟踪用户状态。</p>
<p>2.对于安全性来说，session比存放在客户端的cookie来说安全，用户验证等重要信息一般存放在session，而cookie也可以通过加密来提高它的安全性</p>
<p>3.对于生命周期来说，cookie在使用脚本或用户手动删除前永久保存，最大为4KB，而session在会话期间保存，访问增多会增加服务器负担</p>
<p>4.session的实现需要cookie的支持：session依赖session ID实现，而session ID存放在cookie。</p>
<p>5.session在服务器端可存放文件、数据库或内存</p>
<p>session支持保存各对象，而cookie只保存字符串。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/07/13/blog-remove-1/">在CentOS下搭建ftp服务器遇到的一些问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-13</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/环境配置/">环境配置</a></span><div class="content"><p><strong>系统：CentOS 7.6 64位</strong></p>
<h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h2><blockquote>
<p>在跟着腾讯云文档</p>
<p><a href="https://cloud.tencent.com/document/product/213/10912" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/213/10912</a></p>
<p>搭建Ftp服务器后,输入telnet + 云服务器公网 IP + 21也能够成功连接。</p>
<p>但是在FileZilla连接时出现错误如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 状态:	连接建立，等待欢迎消息...</span><br><span class="line">&gt; 状态:	不安全的服务器，不支持 FTP over TLS。</span><br><span class="line">&gt; 命令:	USER ftpuser1</span><br><span class="line">&gt; 响应:	331 Please specify the password.</span><br><span class="line">&gt; 命令:	PASS **********</span><br><span class="line">&gt; 响应:	530 Login incorrect.</span><br><span class="line">&gt; 错误:	严重错误: 无法连接到服务器</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我随后百度有以下几个解决方案：</p>
<p><a href="https://blog.csdn.net/shuaicenglou3032/article/details/72603131" target="_blank" rel="noopener">https://blog.csdn.net/shuaicenglou3032/article/details/72603131</a></p>
<p>这个是因为操作系统32位原因出错(我这不是)</p>
<p>之后在</p>
<p><a href="https://serverfault.com/questions/180778/vsftpd-530-login-incorrect" target="_blank" rel="noopener">https://serverfault.com/questions/180778/vsftpd-530-login-incorrect</a><br>里找到了解决方案即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/pam.d/vsftpd</span><br><span class="line">注释掉auth       required     pam_shells.so这行</span><br><span class="line">然后 service vsftpd restart</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="pam-shells-so"><a href="#pam-shells-so" class="headerlink" title="pam_shells.so"></a>pam_shells.so</h2><p>这个pam_shells.so是啥意思呢？</p>
<p>我百度了一下<a href="https://www.cnblogs.com/ilinuxer/p/5087447.html" target="_blank" rel="noopener">https://www.cnblogs.com/ilinuxer/p/5087447.html</a></p>
<p>大概是说如果用户想登陆系统，那么它的shell必须是在/etc/shells文件中之一的shell</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/18/blog-remove-2/">this的指向</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-18</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JS/">JS</a></span><div class="content"><h2 id="独立调用与被调用"><a href="#独立调用与被调用" class="headerlink" title="独立调用与被调用"></a>独立调用与被调用</h2><p>在开头，我们说this的指向是在函数被调用的时候确定的。这是因为this的指向在执行上下文被创建时确定的。就是说这段this代码，他运行在不同的环境，this就能指向不同的对象。</p>
<p>先来看一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    x: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function demo () &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); // 10</span><br><span class="line">fn.call(obj); // 20</span><br></pre></td></tr></table></figure>

<p>第一个fn()中，fn()是独立调用的，我调用我自己，所以this指向自己为undefine，但是是为非严格模式，this指向undefined时会自动指向全局变量。而第二个fn.call(obj)可以理解为，fn让obj作为它的调用者，所以this指向调用者obj，所以最后输出为20。</p>
<p>再来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var a = 20;</span><br><span class="line">function foo () &#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        a: 10,</span><br><span class="line">        c: this.a + 20,</span><br><span class="line">        fn: function () &#123;</span><br><span class="line">            return this.a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj.fn;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(foo());</span><br><span class="line">console.log(window.foo());</span><br></pre></td></tr></table></figure>

<p>现在按照上面的思路来推一下</p>
<p>由于foo()是独立调用的，那么它之中的this是指向undefine的，所以第一句console.log(foo())报错：Cannot read property ‘a’ of undefined.</p>
<p>而第二句，foo()有一个调用者是window，所以this全部指向window，最后是全局的a：20 + 20 输出40.</p>
<p>现在对独立调用和被调用应该有了一个大致的理解，对于this的指向也有了初步的认识。</p>
<hr>
<p>我们再看这一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">function foo1()&#123;</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    getA: function () &#123;</span><br><span class="line">        return this.a;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj.getA();</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo1());//10</span><br><span class="line">function foo2()&#123;</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    getA: function () &#123;</span><br><span class="line">        return this.a;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj.getA;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo2()());//20</span><br></pre></td></tr></table></figure>

<p>这个例子说明，我们必须弄明白真正的调用者是谁，foo1中，是直接return this.a，this指向了getA的调用者obj。而foo2()，相当于有一个 var tmp = obj.getA()的操作，函数的调用真正的调用者是tmp自己，这个是独立调用，指向Undefine.</p>
<h2 id="New的原理"><a href="#New的原理" class="headerlink" title="New的原理"></a>New的原理</h2><p>我们知道JS改变this的方法有</p>
<ul>
<li>call</li>
<li>apply</li>
<li>new</li>
</ul>
<p>call和apply可以说是通过给与this一个调用者，来实现this指向的转移，而new呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将构造函数以参数形式传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个中间对象，该对象为最终返回的实例</span></span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将实例的原型指向构造函数的原型</span></span><br><span class="line">        res.__proto__ = func.prototype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象</span></span><br><span class="line">    <span class="keyword">var</span> ret = func.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret === <span class="string">"function"</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res</span></span><br><span class="line"><span class="keyword">var</span> p1 = New(Person, <span class="string">'tom'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，这里也可以判断出实例的类型了</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>通过这个实例我们可以看到new创建了一个空对象，再通过<strong>深拷贝</strong>将创建的实例对象拷贝到返回对象并使用call进行了this的绑定</p>
<h2 id="ES6中的箭头函数"><a href="#ES6中的箭头函数" class="headerlink" title="ES6中的箭头函数"></a>ES6中的箭头函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//对于ES6中的箭头函数来说</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(this.a)&#125;,3000</span><br><span class="line">)</span><br><span class="line">//可以相当于</span><br><span class="line">var _this = this;</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(_this.a);</span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure>

<p>又因为setTimeout是window下的全局函数，所以this，默认指向window</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/15/blog-remove-4/">斐波那契数列的递归实现和顺序实现</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-15</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Alglorithm/">Alglorithm</a></span><div class="content"><blockquote>
<p>今天看《剑指Offer》看到了斐波那契数列其实用递归调用树的话会有很多重复计算……（之前自己就是一直图省事，感觉写的代码少，用递归很方便，但是仔细一想的确是有很多计算是重复的，浪费了很多时间所以今天的随笔就说一下斐波那契的顺序实现吧</p>
</blockquote>
<h2 id="一、常见的递归实现"><a href="#一、常见的递归实现" class="headerlink" title="一、常见的递归实现"></a>一、常见的递归实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num == <span class="number">0</span> || num == <span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci(num<span class="number">-1</span>)+Fibonacci(num - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以前的我一直是用递归写的，因为可以看到，真的很方便(这里写的简单了，没有考虑负数和异常输入之类的，自己编写时还是要多加考虑边界条件和异常输入啦~)</p>
<p>我们可以看出比如Num = 4时 要算Num = 3时的值 + Num = 2的值，而Num = 3时又要算一遍Num = 2的值，就很累赘。所以用顺序结构从1到n这样的话，就能少掉这个麻烦。</p>
<h2 id="二、两种顺序实现"><a href="#二、两种顺序实现" class="headerlink" title="二、两种顺序实现"></a>二、两种顺序实现</h2><h3 id="第一种方法是用两个数不断变换，最终得到目标值"><a href="#第一种方法是用两个数不断变换，最终得到目标值" class="headerlink" title="第一种方法是用两个数不断变换，最终得到目标值"></a>第一种方法是用两个数不断变换，最终得到目标值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*顺序斐波那契额*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>,tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> num1 = <span class="number">0</span>,num2 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) tmp = n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-2</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = num1 + num2;</span><br><span class="line">		num1 = num2;</span><br><span class="line">		num2 = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"fnums is :"</span>&lt;&lt;Fibonacci(n)&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一个方法还可以用来寻找一组数的最大值和次大值，也是循环一遍的O(n)还是很方便的。</p>
<h3 id="第二种是使用队列实现"><a href="#第二种是使用队列实现" class="headerlink" title="第二种是使用队列实现"></a>第二种是使用队列实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.push(<span class="number">0</span>);</span><br><span class="line">	q.push(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty() &amp;&amp; n &gt;= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> y = q.front();</span><br><span class="line">		q.push(x+y);</span><br><span class="line">		n--;</span><br><span class="line">	&#125;</span><br><span class="line">	q.pop();</span><br><span class="line">	<span class="keyword">int</span> result = q.front();</span><br><span class="line">	q.pop();</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"fnums is :"</span>&lt;&lt;Fibonacci(n)&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还有一种方法是数组实现啦<del>我觉得用的空间会大于第一种方式，而且原理也并没什么差别在此就不写啦</del></p>
<p>总之呢，递归虽然代码量少，（可是代码量少并不是决定一个程序员的强弱啊喂！）但是重复计算过程有点点多，然后可怜的栈也会出现STACK OVERFLOW（栈溢出）的错误，所以还是顺序比较好嘛<del>随着n的增大，顺序的优势也会更加明显的</del></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在《剑指Offer》上还说了需要知识迁移的能力，提到了一只青蛙一次可以跳上1级台阶，也可以跳上两级台阶，问青蛙跳上n级台阶总共有几种跳法的问题.</p>
<p>这类问题可以这样想，1级台阶有1种，2级台阶有两种，我们可以知道上3级台阶前，青蛙一定是站在n-2(1)级台阶或者上n-1(2)级台阶，所以就是把F(n-2)+F(n-1)加在一起就是上n级台阶的跳法总数啦，没错，就是你！斐波那契数列！</p>
<p>和这个思维很像的还有汉诺塔问题，要把柱子A的N个圆盘放到C，也就是把柱子A的N-1个圆盘放到B，然后再把第N个圆盘放在C，最后把B柱子通过A放到C，也就是2*F（N-1）+1</p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 By Kiznaiver</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>支持 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Thanks for looking.</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>